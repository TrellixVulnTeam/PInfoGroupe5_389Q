import { from, of, iif, throwError } from 'rxjs';
import { Injectable } from '@angular/core';
import { isHttpInterceptorRouteConfig, AuthClientConfig, } from './auth.config';
import { switchMap, first, concatMap, pluck, catchError } from 'rxjs/operators';
import { AuthService } from './auth.service';
export class AuthHttpInterceptor {
    constructor(configFactory, authService) {
        this.configFactory = configFactory;
        this.authService = authService;
    }
    intercept(req, next) {
        var _a;
        const config = this.configFactory.get();
        if (!((_a = config.httpInterceptor) === null || _a === void 0 ? void 0 : _a.allowedList)) {
            return next.handle(req);
        }
        return this.findMatchingRoute(req, config.httpInterceptor).pipe(concatMap((route) => iif(
        // Check if a route was matched
        () => route !== null, 
        // If we have a matching route, call getTokenSilently and attach the token to the
        // outgoing request
        of(route).pipe(pluck('tokenOptions'), concatMap((options) => this.authService.getAccessTokenSilently(options).pipe(catchError((err) => {
            if (this.allowAnonymous(route, err)) {
                return of('');
            }
            return throwError(err);
        }))), switchMap((token) => {
            // Clone the request and attach the bearer token
            const clone = token
                ? req.clone({
                    headers: req.headers.set('Authorization', `Bearer ${token}`),
                })
                : req;
            return next.handle(clone);
        })), 
        // If the URI being called was not found in our httpInterceptor config, simply
        // pass the request through without attaching a token
        next.handle(req))));
    }
    /**
     * Strips the query and fragment from the given uri
     * @param uri The uri to remove the query and fragment from
     */
    stripQueryFrom(uri) {
        if (uri.indexOf('?') > -1) {
            uri = uri.substr(0, uri.indexOf('?'));
        }
        if (uri.indexOf('#') > -1) {
            uri = uri.substr(0, uri.indexOf('#'));
        }
        return uri;
    }
    /**
     * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against
     * the interceptor route configuration.
     * @param route The route to test
     * @param request The HTTP request
     */
    canAttachToken(route, request) {
        const testPrimitive = (value) => {
            if (!value) {
                return false;
            }
            const requestPath = this.stripQueryFrom(request.url);
            if (value === requestPath) {
                return true;
            }
            // If the URL ends with an asterisk, match using startsWith.
            return (value.indexOf('*') === value.length - 1 &&
                request.url.startsWith(value.substr(0, value.length - 1)));
        };
        if (isHttpInterceptorRouteConfig(route)) {
            if (route.httpMethod && route.httpMethod !== request.method) {
                return false;
            }
            /* istanbul ignore if */
            if (!route.uri && !route.uriMatcher) {
                console.warn('Either a uri or uriMatcher is required when configuring the HTTP interceptor.');
            }
            return route.uriMatcher
                ? route.uriMatcher(request.url)
                : testPrimitive(route.uri);
        }
        return testPrimitive(route);
    }
    /**
     * Tries to match a route from the SDK configuration to the HTTP request.
     * If a match is found, the route configuration is returned.
     * @param request The Http request
     * @param config HttpInterceptorConfig
     */
    findMatchingRoute(request, config) {
        return from(config.allowedList).pipe(first((route) => this.canAttachToken(route, request), null));
    }
    allowAnonymous(route, err) {
        return (!!route &&
            isHttpInterceptorRouteConfig(route) &&
            !!route.allowAnonymous &&
            ['login_required', 'consent_required'].includes(err.error));
    }
}
AuthHttpInterceptor.decorators = [
    { type: Injectable }
];
AuthHttpInterceptor.ctorParameters = () => [
    { type: AuthClientConfig },
    { type: AuthService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL2F1dGgwLWFuZ3VsYXIvc3JjL2xpYi9hdXRoLmludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLE9BQU8sRUFBYyxJQUFJLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBRUwsNEJBQTRCLEVBQzVCLGdCQUFnQixHQUVqQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2hGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUk3QyxNQUFNLE9BQU8sbUJBQW1CO0lBQzlCLFlBQ1UsYUFBK0IsRUFDL0IsV0FBd0I7UUFEeEIsa0JBQWEsR0FBYixhQUFhLENBQWtCO1FBQy9CLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0lBQy9CLENBQUM7SUFFSixTQUFTLENBQ1AsR0FBcUIsRUFDckIsSUFBaUI7O1FBRWpCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDeEMsSUFBSSxDQUFDLENBQUEsTUFBQSxNQUFNLENBQUMsZUFBZSwwQ0FBRSxXQUFXLENBQUEsRUFBRTtZQUN4QyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDekI7UUFFRCxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FDN0QsU0FBUyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDbEIsR0FBRztRQUNELCtC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eEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO2dCQUNuQyxPQUFPLENBQUMsSUFBSSxDQUNWLCtFQUErRSxDQUNoRixDQUFDO2FBQ0g7WUFFRCxPQUFPLEtBQUssQ0FBQyxVQUFVO2dCQUNyQixDQUFDLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO2dCQUMvQixDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM5QjtRQUVELE9BQU8sYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLGlCQUFpQixDQUN2QixPQUF5QixFQUN6QixNQUE2QjtRQUU3QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUNsQyxLQUFLLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUM1RCxDQUFDO0lBQ0osQ0FBQztJQUVPLGNBQWMsQ0FBQyxLQUFnQyxFQUFFLEdBQVE7UUFDL0QsT0FBTyxDQUNMLENBQUMsQ0FBQyxLQUFLO1lBQ1AsNEJBQTRCLENBQUMsS0FBSyxDQUFDO1lBQ25DLENBQUMsQ0FBQyxLQUFLLENBQUMsY0FBYztZQUN0QixDQUFDLGdCQUFnQixFQUFFLGtCQUFrQixDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FDM0QsQ0FBQztJQUNKLENBQUM7OztZQWhKRixVQUFVOzs7WUFSVCxnQkFBZ0I7WUFLVCxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSHR0cEludGVyY2VwdG9yLFxuICBIdHRwUmVxdWVzdCxcbiAgSHR0cEhhbmRsZXIsXG4gIEh0dHBFdmVudCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmcm9tLCBvZiwgaWlmLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gIEFwaVJvdXRlRGVmaW5pdGlvbixcbiAgaXNIdHRwSW50ZXJjZXB0b3JSb3V0ZUNvbmZpZyxcbiAgQXV0aENsaWVudENvbmZpZyxcbiAgSHR0cEludGVyY2VwdG9yQ29uZmlnLFxufSBmcm9tICcuL2F1dGguY29uZmlnJztcblxuaW1wb3J0IHsgc3dpdGNoTWFwLCBmaXJzdCwgY29uY2F0TWFwLCBwbHVjaywgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEF1dGhTZXJ2aWNlIH0gZnJvbSAnLi9hdXRoLnNlcnZpY2UnO1xuaW1wb3J0IHsgR2V0VG9rZW5TaWxlbnRseU9wdGlvbnMgfSBmcm9tICdAYXV0aDAvYXV0aDAtc3BhLWpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEF1dGhIdHRwSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbmZpZ0ZhY3Rvcnk6IEF1dGhDbGllbnRDb25maWcsXG4gICAgcHJpdmF0ZSBhdXRoU2VydmljZTogQXV0aFNlcnZpY2VcbiAgKSB7fVxuXG4gIGludGVyY2VwdChcbiAgICByZXE6IEh0dHBSZXF1ZXN0PGFueT4sXG4gICAgbmV4dDogSHR0cEhhbmRsZXJcbiAgKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnRmFjdG9yeS5nZXQoKTtcbiAgICBpZiAoIWNvbmZpZy5odHRwSW50ZXJjZXB0b3I/LmFsbG93ZWRMaXN0KSB7XG4gICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5kTWF0Y2hpbmdSb3V0ZShyZXEsIGNvbmZpZy5odHRwSW50ZXJjZXB0b3IpLnBpcGUoXG4gICAgICBjb25jYXRNYXAoKHJvdXRlKSA9PlxuICAgICAgICBpaWYoXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYSByb3V0ZSB3YXMgbWF0Y2hlZFxuICAgICAgICAgICgpID0+IHJvdXRlICE9PSBudWxsLFxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaGluZyByb3V0ZSwgY2FsbCBnZXRUb2tlblNpbGVudGx5IGFuZCBhdHRhY2ggdGhlIHRva2VuIHRvIHRoZVxuICAgICAgICAgIC8vIG91dGdvaW5nIHJlcXVlc3RcbiAgICAgICAgICBvZihyb3V0ZSkucGlwZShcbiAgICAgICAgICAgIHBsdWNrKCd0b2tlbk9wdGlvbnMnKSxcbiAgICAgICAgICAgIGNvbmNhdE1hcDxHZXRUb2tlblNpbGVudGx5T3B0aW9ucywgT2JzZXJ2YWJsZTxzdHJpbmc+Pigob3B0aW9ucykgPT5cbiAgICAgICAgICAgICAgdGhpcy5hdXRoU2VydmljZS5nZXRBY2Nlc3NUb2tlblNpbGVudGx5KG9wdGlvbnMpLnBpcGUoXG4gICAgICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd0Fub255bW91cyhyb3V0ZSwgZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YoJycpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIHJlcXVlc3QgYW5kIGF0dGFjaCB0aGUgYmVhcmVyIHRva2VuXG4gICAgICAgICAgICAgIGNvbnN0IGNsb25lID0gdG9rZW5cbiAgICAgICAgICAgICAgICA/IHJlcS5jbG9uZSh7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcS5oZWFkZXJzLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiByZXE7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKGNsb25lKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBJZiB0aGUgVVJJIGJlaW5nIGNhbGxlZCB3YXMgbm90IGZvdW5kIGluIG91ciBodHRwSW50ZXJjZXB0b3IgY29uZmlnLCBzaW1wbHlcbiAgICAgICAgICAvLyBwYXNzIHRoZSByZXF1ZXN0IHRocm91Z2ggd2l0aG91dCBhdHRhY2hpbmcgYSB0b2tlblxuICAgICAgICAgIG5leHQuaGFuZGxlKHJlcSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU3RyaXBzIHRoZSBxdWVyeSBhbmQgZnJhZ21lbnQgZnJvbSB0aGUgZ2l2ZW4gdXJpXG4gICAqIEBwYXJhbSB1cmkgVGhlIHVyaSB0byByZW1vdmUgdGhlIHF1ZXJ5IGFuZCBmcmFnbWVudCBmcm9tXG4gICAqL1xuICBwcml2YXRlIHN0cmlwUXVlcnlGcm9tKHVyaTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodXJpLmluZGV4T2YoJz8nKSA+IC0xKSB7XG4gICAgICB1cmkgPSB1cmkuc3Vic3RyKDAsIHVyaS5pbmRleE9mKCc/JykpO1xuICAgIH1cblxuICAgIGlmICh1cmkuaW5kZXhPZignIycpID4gLTEpIHtcbiAgICAgIHVyaSA9IHVyaS5zdWJzdHIoMCwgdXJpLmluZGV4T2YoJyMnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCByb3V0ZSBjYW4gaGF2ZSBhbiBhY2Nlc3MgdG9rZW4gYXR0YWNoZWQgdG8gaXQsIGJhc2VkIG9uIG1hdGNoaW5nIHRoZSBIVFRQIHJlcXVlc3QgYWdhaW5zdFxuICAgKiB0aGUgaW50ZXJjZXB0b3Igcm91dGUgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHJvdXRlIFRoZSByb3V0ZSB0byB0ZXN0XG4gICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBIVFRQIHJlcXVlc3RcbiAgICovXG4gIHByaXZhdGUgY2FuQXR0YWNoVG9rZW4oXG4gICAgcm91dGU6IEFwaVJvdXRlRGVmaW5pdGlvbixcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+XG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRlc3RQcmltaXRpdmUgPSAodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IGJvb2xlYW4gPT4ge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVlc3RQYXRoID0gdGhpcy5zdHJpcFF1ZXJ5RnJvbShyZXF1ZXN0LnVybCk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gcmVxdWVzdFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBVUkwgZW5kcyB3aXRoIGFuIGFzdGVyaXNrLCBtYXRjaCB1c2luZyBzdGFydHNXaXRoLlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgdmFsdWUuaW5kZXhPZignKicpID09PSB2YWx1ZS5sZW5ndGggLSAxICYmXG4gICAgICAgIHJlcXVlc3QudXJsLnN0YXJ0c1dpdGgodmFsdWUuc3Vic3RyKDAsIHZhbHVlLmxlbmd0aCAtIDEpKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgaWYgKGlzSHR0cEludGVyY2VwdG9yUm91dGVDb25maWcocm91dGUpKSB7XG4gICAgICBpZiAocm91dGUuaHR0cE1ldGhvZCAmJiByb3V0ZS5odHRwTWV0aG9kICE9PSByZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFyb3V0ZS51cmkgJiYgIXJvdXRlLnVyaU1hdGNoZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdFaXRoZXIgYSB1cmkgb3IgdXJpTWF0Y2hlciBpcyByZXF1aXJlZCB3aGVuIGNvbmZpZ3VyaW5nIHRoZSBIVFRQIGludGVyY2VwdG9yLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvdXRlLnVyaU1hdGNoZXJcbiAgICAgICAgPyByb3V0ZS51cmlNYXRjaGVyKHJlcXVlc3QudXJsKVxuICAgICAgICA6IHRlc3RQcmltaXRpdmUocm91dGUudXJpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVzdFByaW1pdGl2ZShyb3V0ZSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZXMgdG8gbWF0Y2ggYSByb3V0ZSBmcm9tIHRoZSBTREsgY29uZmlndXJhdGlvbiB0byB0aGUgSFRUUCByZXF1ZXN0LlxuICAgKiBJZiBhIG1hdGNoIGlzIGZvdW5kLCB0aGUgcm91dGUgY29uZmlndXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIEh0dHAgcmVxdWVzdFxuICAgKiBAcGFyYW0gY29uZmlnIEh0dHBJbnRlcmNlcHRvckNvbmZpZ1xuICAgKi9cbiAgcHJpdmF0ZSBmaW5kTWF0Y2hpbmdSb3V0ZShcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIGNvbmZpZzogSHR0cEludGVyY2VwdG9yQ29uZmlnXG4gICk6IE9ic2VydmFibGU8QXBpUm91dGVEZWZpbml0aW9uIHwgbnVsbD4ge1xuICAgIHJldHVybiBmcm9tKGNvbmZpZy5hbGxvd2VkTGlzdCkucGlwZShcbiAgICAgIGZpcnN0KChyb3V0ZSkgPT4gdGhpcy5jYW5BdHRhY2hUb2tlbihyb3V0ZSwgcmVxdWVzdCksIG51bGwpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYWxsb3dBbm9ueW1vdXMocm91dGU6IEFwaVJvdXRlRGVmaW5pdGlvbiB8IG51bGwsIGVycjogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgICEhcm91dGUgJiZcbiAgICAgIGlzSHR0cEludGVyY2VwdG9yUm91dGVDb25maWcocm91dGUpICYmXG4gICAgICAhIXJvdXRlLmFsbG93QW5vbnltb3VzICYmXG4gICAgICBbJ2xvZ2luX3JlcXVpcmVkJywgJ2NvbnNlbnRfcmVxdWlyZWQnXS5pbmNsdWRlcyhlcnIuZXJyb3IpXG4gICAgKTtcbiAgfVxufVxuIl19